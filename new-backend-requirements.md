## Введение

Сейчас студенты курса iOS на дипломном проекте работают с сервисом [mockapi](https://mockapi.io) - простейший бэкенд, который сохраняет и отдаёт содержимое JSON по GET и PUT запросам. Но у mockapi есть ряд недостатков, из-за которых мы хотим свой бэкенд.

Для информации: [требования](https://github.com/Yandex-Practicum/iOS-FakeNFT-StarterProject-Public) / [дизайн](https://www.figma.com/file/k1LcgXHGTHIeiCv4XuPbND/FakeNFT-(YP)?node-id=96-5542&t=YdNbOI8EcqdYmDeg-0) iOS-приложения.

## 1. Запросы к разным хостам

Каждая команда студентов работает со своим хостом. Мы выдаём своё имя хоста каждой новой команде, предыдущие продолжают работать (проект остаётся в портфолио у студентов и должен быть рабочим). У mockapi есть админка для этого, наставник заходит туда и клонирует проект, студент получает уникальный урл, например, "https://64858e8ba795d24810b71189.mockapi.io"

Варианты решения:
1. Сделать админку для управления клонами проекта. Выглядит сложно и долго.
2. Не делать админку, а даём доступ по любому UUID в урле, например, если у нас домен yandex-example.com, то для получения нового экземпляра-хоста дописываем UUID (уникальный UUID для данной команды) в поддомен и получаем урл:
1dbcf3fb-e0cb-45d5-ba12-7587c24b3054.yandex-example.com

## 2. Перечень запросов

GET и PUT запросы описаны в сваггере: https://github.com/yandex-practicum-ios/fakenft/blob/main/openapi3_0.json

Данные по каждому хосту при первом обращении инициализируются дефолтными значениями (указаны в сваггере) и не пересекаются между экземплярами.

То, что положили в PUT для данного хоста, эти же данные должен вернуть соответствуютий запрос GET.

Для всех PUT-запросов все параметры являются опциональными.

## 3. Контроль схемы данных

Необходимо строго контролировать указанные типы данных. Если запрос составлен некорректно, возвращать соответствующие HTTP 4XX ошибки, по возможности с информативным текстом ошибки.

(недостаток mockapi - он сохраняет любые JSON, даже если схема данных не совпадает, т.е. студенты могут сломать API)

## 4. Контроль лимитов

Необходимо ограничить лимит запросов. При превышении отдавать HTTP 429.

Ориентировочные цифры для начала: 100 запросов в минуту с одного IP

## 5. Фильтрация

Чтобы отфильтровать данные по любым полям, к GET-запросу добавляем GET-параметр `search`:

Запрос `/users?search=market` должен вернуть юзеров, у которых в любом поле содержится market (поиск не чувствителен к регистру)

Вместо этого, для поиска по конкретному полю указываем 

Запрос `/users?name=sebastian%20th` должен вернуть юзеров, у которых в имени содержится подстрока «sebastian th» (поиск не чувствителен к регистру)

Исключение из предыдущего запроса: при фильтрации по id ищем не подстроку, а точное соответствие: /users?id=1 возвращает только одного юзера с id=1, а не всех с подстрокой 1.

## 6. Сортировка

Задаём GET-параметр `sortBy` с названием нужного поля.
Направление сортировки - параметр `order`: по увеличению `asc` или по уменьшению `desc`.

Например: `/users?sortBy=name&order=desc`

## 7. Пагинация

Указываем GET-параметры:
- `page` - номер страницы
- `limit` - число записей на странице

Например: /users?page=1&limit=10

Важно: пагинация должна корректно работать в сочетании с сортировкой и фильтрацией.

## 8. Загрузка картинок

У mockapi нет загрузки картинок, а при запросе PUT /profile подразумавалась загрузка картинки. Если есть такая техническая возможность, создать отдельный POST-запрос, который принимает картинку (с заданным лимитом по размеру, это может быть порядка 100-500 кбайт), сохраняет её в некую папку со статикой и отдаёт урл, по которому картинка становится доступна через GET-запрос.
